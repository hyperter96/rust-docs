import{_ as i}from"./chunks/ArticleMetadata.B6LTgUMn.js";import{_ as c,m as l,a as _,u as d,B as u,e as o,x as p,ai as m,o as s,p as h,q as f}from"./chunks/framework.coFu0xgG.js";import"./chunks/theme.CAIqAJ98.js";const A=JSON.parse('{"title":"多线程编程","description":"","frontmatter":{"title":"多线程编程","author":"皮特ᴾᵗ","date":"2024/05/26 14:11","categories":["Rust语法进阶"],"tags":["Rust","Rust基础","多线程"]},"headers":[],"relativePath":"categories/rust/02-Rust语法进阶/02-多线程编程.md","filePath":"categories/rust/02-Rust语法进阶/02-多线程编程.md","lastUpdated":1718264116000}'),R={name:"categories/rust/02-Rust语法进阶/02-多线程编程.md"},g=o("h1",{id:"多线程编程",tabindex:"-1"},[p("多线程编程 "),o("a",{class:"header-anchor",href:"#多线程编程","aria-label":'Permalink to "多线程编程"'},"​")],-1),k=m('<p>安全和高效的处理并发是 Rust 语言的主要目标之一。随着现代处理器的核心数不断增加，并发和并行已经成为日常编程不可或缺的一部分，甚至于 Go 语言已经将并发简化到一个 go 关键字就可以。</p><p>可惜的是，在 Rust 中由于语言设计理念、安全、性能的多方面考虑，并没有采用 Go 语言大道至简的方式，而是选择了多线程与 <code>async/await</code> 相结合，优点是可控性更强、性能更高，缺点是复杂度并不低，当然这也是系统级语言的应有选择：使用复杂度换取可控性和性能。</p><p>不过，大家也不用担心，本书的目标就是降低 Rust 使用门槛，这个门槛自然也包括如何在 Rust 中进行异步并发编程，我们将从多线程以及 <code>async/await</code> 两个方面去深入浅出地讲解，首先，从本章的多线程开始。</p><p>在本章，我们将深入讲解并发和并行的区别以及如何使用多线程进行 Rust 并发编程，那么先来看看何为并行与并发。</p><h2 id="使用多线程" tabindex="-1">使用多线程 <a class="header-anchor" href="#使用多线程" aria-label="Permalink to &quot;使用多线程&quot;">​</a></h2><p>由于多线程的代码是同时运行的，因此我们无法保证线程间的执行顺序，这会导致一些问题：</p><ul><li>竞态条件(race conditions)，多个线程以非一致性的顺序同时访问数据资源</li><li>死锁(deadlocks)，两个线程都想使用某个资源，但是又都在等待对方释放资源后才能使用，结果最终都无法继续执行</li><li>一些因为多线程导致的很隐晦的 BUG，难以复现和解决</li></ul><p>虽然 Rust 已经通过各种机制减少了上述情况的发生，但是依然无法完全避免上述情况，因此我们在编程时需要格外的小心，同时本书也会列出多线程编程时常见的陷阱，让你提前规避可能的风险。</p>',8);function C(t,N,T,V,$,B){const r=i,n=l("ClientOnly");return s(),_("div",null,[g,d(n,null,{default:u(()=>{var e,a;return[(((e=t.$frontmatter)==null?void 0:e.aside)??!0)&&(((a=t.$frontmatter)==null?void 0:a.showArticleMetadata)??!0)?(s(),h(r,{key:0,article:t.$frontmatter},null,8,["article"])):f("",!0)]}),_:1}),k])}const S=c(R,[["render",C]]);export{A as __pageData,S as default};
