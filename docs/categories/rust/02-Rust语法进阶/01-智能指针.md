---
title: æ™ºèƒ½æŒ‡é’ˆ
author: çš®ç‰¹á´¾áµ—
date: 2024/05/25 12:21
categories:
 - Rustè¯­æ³•è¿›é˜¶
tags:
 - Rust
 - RuståŸºç¡€
 - æ™ºèƒ½æŒ‡é’ˆ
---

# æ™ºèƒ½æŒ‡é’ˆ

## æ™ºèƒ½æŒ‡é’ˆæ¦‚å†µ

æŒ‡é’ˆæ˜¯ä¸€ä¸ªåŒ…å«å†…å­˜åœ°å€çš„å˜é‡ã€‚è¿™ä¸ªåœ°å€æŒ‡å‘ä¸€äº›å…¶ä»–çš„æ•°æ®ã€‚

### ä»€ä¹ˆæ˜¯æ™ºèƒ½æŒ‡é’ˆ

æ™ºèƒ½æŒ‡é’ˆï¼š

- æ™ºèƒ½æŒ‡é’ˆæ˜¯ä¸€ç±»æ•°æ®ç»“æ„ï¼Œå®ƒä»¬è¡¨ç°ç±»ä¼¼äºæŒ‡é’ˆï¼Œä½†æ˜¯ä¹Ÿæ‹¥æœ‰é¢å¤–çš„å…ƒæ•°æ®ï¼Œæœ€æ˜æ˜¾çš„ï¼Œå®ƒä»¬æ‹¥æœ‰ä¸€ä¸ªå¼•ç”¨è®¡æ•°ã€‚å¼•ç”¨è®¡æ•°è®°å½•æ™ºèƒ½æŒ‡é’ˆæ€»å…±æœ‰å¤šå°‘ä¸ªæ‰€æœ‰è€…ï¼Œå¹¶ä¸”å½“æ²¡æœ‰ä»»ä½•æ‰€æœ‰è€…æ—¶æ¸…æ¥šæ•°æ®ã€‚
- æ™ºèƒ½æŒ‡é’ˆé€šå¸¸ä½¿ç”¨ç»“æ„ä½“å®ç°ã€‚æ™ºèƒ½æŒ‡é’ˆåŒºåˆ«äºå¸¸è§„ç»“æ„ä½“çš„æ˜¾è‘—ç‰¹å¾åœ¨äºå…¶å®ç°äº†`Deref`å’Œ`Drop trait`ã€‚
    - `Deref trait`å…è®¸æ™ºèƒ½æŒ‡é’ˆç»“æ„ä½“å®ä¾‹è¡¨ç°çš„åƒå¼•ç”¨ä¸€æ ·ï¼Œè¿™æ ·å°±å¯ä»¥ç¼–å†™å³ç”¨äºå¼•ç”¨ï¼Œåˆç”¨äºæ™ºèƒ½æŒ‡é’ˆçš„ä»£ç 
    - `Drop trait`å…è®¸æˆ‘ä»¬è‡ªå®šä¹‰å½“æ™ºèƒ½æŒ‡é’ˆç¦»å¼€ä½œç”¨åŸŸæ—¶æ‰§è¡Œçš„ä»£ç 

æ™®é€šå¼•ç”¨å’Œæ™ºèƒ½æŒ‡é’ˆçš„ä¸€ä¸ªé¢å¤–åŒºåˆ«æ˜¯ï¼šå¼•ç”¨åªæ˜¯å€Ÿç”¨æ•°æ®çš„æŒ‡é’ˆï¼Œè€Œæ™ºèƒ½æŒ‡é’ˆåˆ™æ˜¯æ‹¥æœ‰å®ƒä»¬æŒ‡å‘çš„æ•°æ®ã€‚

### å‡ ä¸ªæ ‡å‡†åº“ä¸­çš„æ™ºèƒ½æŒ‡é’ˆ

- Boxæ˜¯æœ€ç®€å•çš„æ™ºèƒ½æŒ‡é’ˆï¼Œåªæ˜¯ç”¨äºHeapå †ä¸Šåˆ†é…
- RcæŒ‡é’ˆæ˜¯ä¸ºäº†å®Œæˆshare ownershipçš„åŠŸèƒ½ï¼Œæ˜¯æ™ºèƒ½æŒ‡é’ˆçš„æ ¸å¿ƒï¼Œå…¶æ•°æ®å¯ä»¥æœ‰å¤šä¸ªæ‰€æœ‰è€…
    - WeakæŒ‡é’ˆå¼±å¼•ç”¨
    - Arcæ˜¯å¤šçº¿ç¨‹çš„Rc
    - Mutexæ˜¯æä¾›äº†å¯å˜æ€§
- Rustæä¾›äº†`Cell`å’Œ`RefCell`ç”¨äºå†…éƒ¨å¯å˜æ€§

:::warning æ³¨æ„ğŸ“¢:
å°½é‡ä¸è¦ä½¿ç”¨`RefCell`ã€‚
:::

## `Box`æŒ‡é’ˆ

### `Box`æŒ‡é’ˆé€‚ç”¨åœºæ™¯

boxé€‚ç”¨äºä»¥ä¸‹åœºæ™¯ï¼š
- å½“æœ‰ä¸€ä¸ªåœ¨ç¼–è¯‘æ—¶æœªçŸ¥å¤§å°çš„ç±»å‹ï¼Œè€Œåˆéœ€è¦å†ç¡®åˆ‡å¤§å°çš„ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨è¿™ä¸ªç±»å‹å€¼çš„æ—¶å€™ï¼ˆè­¬å¦‚ï¼Œå†ä¸€ä¸ª`List`ç¯å¢ƒä¸‹ï¼Œå­˜æ”¾æ•°æ®ï¼Œä½†æ˜¯æ¯ä¸ªå…ƒç´ çš„å¤§å°åœ¨ç¼–è¯‘æ—¶åˆä¸ç¡®å®šï¼‰
- å½“æœ‰å¤§é‡æ•°æ®å¹¶å¸Œæœ›åœ¨ç¡®ä¿æ•°æ®ä¸è¢«æ‹·è´çš„æƒ…å†µä¸‹è½¬ç§»æ‰€æœ‰æƒçš„æ—¶å€™
- å½“å¸Œæœ›æ‹¥æœ‰ä¸€ä¸ªå€¼å¹¶å…³å¿ƒå®ƒçš„ç±»å‹æ˜¯å¦å®ç°äº†ç‰¹å®štraitè€Œä¸æ˜¯å…¶å…·ä½“ç±»å‹æ—¶

ç¬¬ä¸€ç§åœºæ™¯ä¸‹ï¼Œå‡å¦‚æˆ‘ä»¬ç°åœ¨æœ‰è¿™æ ·ä¸€ä¸ª`List`æšä¸¾ï¼Œ

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```

å½“ç¼–è¯‘å™¨ç¼–è¯‘çš„æ—¶å€™å› ä¸º`List`æšä¸¾å­˜åœ¨é€’å½’ï¼Œå¹¶ä¸çŸ¥é“`List`æšä¸¾åº”è¯¥åˆ†é…å¤šå¤§çš„å†…å­˜ï¼Œè¿™æ—¶å€™é‡‡ç”¨`Box`çš„è¯ï¼ŒæŒ‡é’ˆæ˜¯æœ‰å†…å­˜å›ºå®šå¤§å°çš„ã€‚è¿™æ ·ç¼–è¯‘çš„è¯ä¼šé€šè¿‡ï¼Œ

```rust
use crate::List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, Box<List>),
    Nil,
}

trait Animal {
    fn eat(&self);
}

#[derive(Debug)]
struct Cat {
    children: Option<Box<Cat>>,
}

impl Animal for Cat {
    fn eat(&self) {
        println!("cat is eating");
    }
}
fn main() {
    let b = Box::new(5); // bå­˜å‚¨åœ¨æ ˆä¸Šï¼Œ5å­˜å‚¨åœ¨å †ä¸Šï¼ŒbæŒ‡å‘5æ‰€åœ¨çš„å†…å­˜
    println!("b = {}", b);
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
    println!("{:?}", list); // Cons(1, Cons(2, Cons(3, Nil)))

    let cat = Box::new(Cat{ children: None });
    println!("{:?}", cat); // Cat { children: None }
    let t: Box<dyn Animal>;
    t = Box::new(Cat {
        children: Some(cat),
    });
    t.eat(); // cat is eating
}
```

## è§£å¼•ç”¨

å®ç°è§£å¼•ç”¨å’Œè‡ªå®šä¹‰`MyBox`,

```rust
use std::ops::Deref;
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

fn main() {
    let x = 5;
    let y = &x;
    assert_eq!(5, x);
    assert_eq!(5, *y); // è§£å¼•ç”¨

    let z = Box::new(x);
    assert_eq!(5, *z);

    // éœ€è¦å®ç°Derefç‰¹è´¨
    let a = MyBox::new(x);
    assert_eq!(5, *a);

    let m = MyBox::new(String::from("Rust"));
    hello(&m); // è§£å¼•ç”¨çš„å¼ºåˆ¶å¤šæ€ï¼šå°†MyBoxå˜ä¸º&String, å†å°†Stringè§£å¼•ç”¨ï¼Œå˜ä¸º&str, 
    println!("hello world");
}

fn hello(s: &str) {
    println!("hello {s}");
}
```

è§£å¼•ç”¨å¤šæ€ä¸å¯å˜æ€§äº¤äº’ï¼š

- å½“`T: Deref<Target=U>`æ—¶ï¼Œä»`&T`åˆ°`&U`
- å½“`T: DerefMut<Target=U>`æ—¶ï¼Œä»`&mut T`åˆ°`&mut U`
- å½“`T: Deref<Target=U>`æ—¶ï¼Œä»`&mut T`åˆ°`&U`

## åŸå§‹æŒ‡é’ˆ

- å£°æ˜éœ€è¦`as`æ¥æ ‡æ³¨ç±»å‹ä»¥åŠå¯å˜æˆ–è€…ä¸å¯å˜
- è§£å¼•ç”¨åˆ™éœ€è¦`unsafe`

```rust
fn main() {
    // æŒ‡é’ˆä¸å¯å˜
    let x: usize = 1;
    let raw_ptr = &x as *const usize;

    // æŒ‡é’ˆå¯å˜
    let mut y: usize = 2;
    let raw_mut_ptr = &mut y as *mut usize;

    let some_usize = unsafe {
        *raw_ptr
    };
    println!("some usize: {some_usize}"); // some usize: 1

    let some_mut_usize = unsafe {
        *raw_mut_ptr
    };
    println!("some mut usize: {some_mut_usize}"); // some mut usize: 2
}
```

## RcæŒ‡é’ˆ

RcæŒ‡é’ˆå¼å­˜å‚¨`ref count`çš„èƒ–æŒ‡é’ˆã€‚

- RcæŒ‡é’ˆçš„è¿½è¸ªçš„ä¸¤ä¸ªæ–¹å‘
    - å¯¹å•ä¸ªå€¼çš„å¤šä¸ªå¼•ç”¨
    - ä½•æ—¶é”€æ¯è¯¥å˜é‡
- `Rc::clone`ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„referenceï¼Œè®¡æ•°åŠ ä¸€
- ç›¸å¯¹äºArcï¼ŒRcæŒ‡é’ˆåªèƒ½è¿è¡Œäºå•çº¿ç¨‹
- Rcç›¸å¯¹äºWeakï¼ŒRcæ˜¯Strong

å…ˆçœ‹å¦‚ä¸‹ï¼š

```rust
use crate::List::{Cons, Nil};
enum List {
    Cons(i32, Box<List>),
    Nil,
}
fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```

å‡ºç°å¦‚ä¸‹æŠ¥é”™ï¼š

```text
 --> src/main.rs:9:30
  |
7 |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
  |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
8 |     let b = Cons(3, Box::new(a));
  |                              - value moved here
9 |     let c = Cons(4, Box::new(a));
  |                              ^ value used here after move
```

è¿™æ—¶`b`å·²ç»æ‹¿åˆ°`a`çš„æ‰€æœ‰æƒï¼Œ`c`ä¸èƒ½å†ä½¿ç”¨`a`äº†ï¼Œè¿™ç§æƒ…å†µä¸‹ä½¿ç”¨RcæŒ‡é’ˆæŠŠ`a`å„å…‹éš†ä¸€ä»½ç»™`b`å’Œ`c`ï¼Œå†™æ³•å¦‚ä¸‹

```rust
use crate::List::{Cons, Nil};
use std::rc::Rc;

enum List {
    Cons(i32, Rc<List>),
    Nil,
}

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
    let d = Cons(6, a.clone()); // å¦ä¸€ç§å†™æ³•
    let e = Cons(7, a.clone());
}
```

ç°åœ¨æˆ‘ä»¬ç»™`a`åšå¼•ç”¨è®¡æ•°ï¼Œ

```rust
use crate::List::{Cons, Nil};
use std::rc::Rc;

enum List {
    Cons(i32, Rc<List>),
    Nil,
}
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a: {}", Rc::strong_count(&a)); // count after creating a: 1
    let b = Cons(3, Rc::clone(&a));
    println!("count after binding to b, a count: {}", Rc::strong_count(&a)); // count after binding to b, a count: 2
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after binding to c, a count: {}", Rc::strong_count(&a)); // count after binding to c, a count: 3
    }
    println!("count at end a: {}", Rc::strong_count(&a)); // count at end a: 2 ç”±äºcç¦»å¼€ä½œç”¨åŸŸ
    let d = Cons(6, a.clone()); // å¦ä¸€ç§å†™æ³•
    let e = Cons(7, a.clone());
}
```

## `Cell`å’Œ`RefCell`

Rustæä¾›äº†`Cell`å’Œ`RefCell`ç”¨äºå†…éƒ¨å¯å˜æ€§ï¼Œå¸¦æ¥äº†çµæ´»æ€§ï¼ŒåŒæ ·ä¹Ÿå¸¦æ¥äº†ä¸€äº›å®‰å…¨çš„éšæ‚£ã€‚

`RefCell`ï¼š

1. å†…éƒ¨å¯å˜æ€§ï¼šå…è®¸åœ¨ä½¿ç”¨ä¸å¯å˜å¼•ç”¨æ—¶æ”¹å˜æ•°æ®ã€‚
2. é€šè¿‡`RefCell<T>`åœ¨è¿è¡Œæ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™ï¼ˆé€šå¸¸æƒ…å†µä¸‹ï¼Œæ˜¯åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™ï¼‰ï¼Œ`RefCell<T>`ä»£è¡¨å…¶æ•°æ®çš„**å”¯ä¸€**æ‰€æœ‰æƒã€‚
3. ç±»ä¼¼äº`Rc<T>`ï¼Œ`RefCell<T>`åªèƒ½ç”¨äº**å•çº¿ç¨‹åœºæ™¯**ã€‚

### é€‰æ‹©`Box<T>`ã€`Rc<T>`æˆ–`RefCell<T>`çš„ç†ç”±

- `Rc<T>`å…è®¸ç›¸åŒæ•°æ®æœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼ˆæ•°æ®åªè¯»å…±äº«ï¼‰ï¼Œ`Box<T>`å’Œ`RefCell<T>`æœ‰å•ä¸€æ‰€æœ‰è€…ã€‚
- `Box<T>`å…è®¸åœ¨**ç¼–è¯‘æ—¶**æ‰§è¡Œ**ä¸å¯å˜æˆ–å¯å˜å€Ÿç”¨**æ£€æŸ¥ï¼›`Rc<T>`ä»…å…è®¸åœ¨**ç¼–è¯‘æ—¶**æ‰§è¡Œ**ä¸å¯å˜å€Ÿç”¨**æ£€æŸ¥ï¼›`RefCell<T>`å…è®¸åœ¨**è¿è¡Œæ—¶**æ‰§è¡Œ**ä¸å¯å˜æˆ–å¯å˜å€Ÿç”¨**æ£€æŸ¥ã€‚
    
    å› ä¸º`RefCell<T>`å…è®¸åœ¨è¿è¡Œæ—¶æ‰§è¡Œå¯å˜å€Ÿç”¨æ£€æŸ¥ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨å³ä½¿`RefCell<T>`è‡ªèº«æ˜¯ä¸å¯å˜çš„æƒ…å†µä¸‹ä¿®æ”¹å…¶å†…éƒ¨çš„å€¼ã€‚

### `Cell`å’Œ`RefCell`çš„åŒºåˆ«

- `Cell`åªé€‚ç”¨äº`Copy`ç±»å‹ï¼Œç”¨äºæä¾›å€¼ï¼Œè€Œ`RefCell`ç”¨äºæä¾›å¼•ç”¨
- `Cell`ä¸ä¼š`panic`ï¼Œè€Œ`RefCell`ä¼š

```rust
use crate::List::{Cons, Nil};
use std::rc::Rc;
use std::cell::{Cell, RefCell};

#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}
fn main() {
    let val = Rc::new(RefCell::new(5));
    let a = Rc::new(Cons(Rc::clone(&val), Rc::new(Nil)));
    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(7)), Rc::clone(&a));

    println!("a before {:?}", a); // a before Cons(RefCell { value: 5 }, Nil)
    println!("b before {:?}", b); // b before Cons(RefCell { value: 6 }, Cons(RefCell { value: 5 }, Nil))
    println!("c before {:?}", c); // c before Cons(RefCell { value: 7 }, Cons(RefCell { value: 5 }, Nil))

    *val.borrow_mut() += 10; // ä¿®æ”¹å†…éƒ¨çš„RefCellï¼ŒRcæ˜¯åªè¯»çš„ä¸å¯å˜å¼•ç”¨ï¼Œåªæä¾›æ•°æ®å…±äº«
    println!("a after {:?}", a); // a after Cons(RefCell { value: 15 }, Nil)
    println!("b after {:?}", b); // b after Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
    println!("c after {:?}", c); // c after Cons(RefCell { value: 7 }, Cons(RefCell { value: 15 }, Nil))

    // &stræ˜¯copy, Stringä¸copy
    let c = Cell::new("yzzy");
    let c1 = c.get();
    println!("{c1}"); // yzzy

    c.set("åŸå­");
    let c2 = c.get();
    println!("{c1}"); // yzzy
    println!("{c2}"); // åŸå­
}
```

## å¾ªç¯å¼•ç”¨å’Œè‡ªå¼•ç”¨

### å¾ªç¯å¼•ç”¨æ˜¯ä»€ä¹ˆ

Rust çš„å®‰å…¨æ€§æ˜¯ä¼—æ‰€å‘¨çŸ¥çš„ï¼Œä½†æ˜¯ä¸ä»£è¡¨å®ƒä¸ä¼šå†…å­˜æ³„æ¼ã€‚ä¸€ä¸ªå…¸å‹çš„ä¾‹å­å°±æ˜¯åŒæ—¶ä½¿ç”¨ `Rc<T>` å’Œ `RefCell<T>` åˆ›å»ºå¾ªç¯å¼•ç”¨ï¼Œæœ€ç»ˆè¿™äº›å¼•ç”¨çš„è®¡æ•°éƒ½æ— æ³•è¢«å½’é›¶ï¼Œå› æ­¤ `Rc<T>` æ‹¥æœ‰çš„å€¼ä¹Ÿä¸ä¼šè¢«é‡Šæ”¾æ¸…ç†ã€‚

```rust
use std::rc::Rc;
use std::cell::RefCell;
use crate::List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}
```

è¿™é‡Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæœ‰äº›å¤æ‚çš„æšä¸¾ç±»å‹ `List`ï¼Œè¿™ä¸ªç±»å‹å¾ˆæœ‰æ„æ€ï¼Œå®ƒçš„æ¯ä¸ªå€¼éƒ½æŒ‡å‘äº†å¦ä¸€ä¸ª `List`ï¼Œæ­¤å¤–ï¼Œå¾—ç›Šäº Rc çš„ä½¿ç”¨è¿˜å…è®¸å¤šä¸ªå€¼æŒ‡å‘ä¸€ä¸ª `List`ï¼š

![](https://pica.zhimg.com/80/v2-0db007dfb4167ebc22f50cf5b5a85f53_1440w.png)

å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œæ¯ä¸ªçŸ©å½¢æ¡†èŠ‚ç‚¹éƒ½æ˜¯ä¸€ä¸ª `List` ç±»å‹ï¼Œå®ƒä»¬æˆ–è€…æ˜¯æ‹¥æœ‰å€¼ä¸”æŒ‡å‘å¦ä¸€ä¸ª `List` çš„`Cons`ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªæ²¡æœ‰å€¼çš„ç»ˆç»“ç‚¹ `Nil`ã€‚åŒæ—¶ï¼Œç”±äº `RefCell` çš„ä½¿ç”¨ï¼Œæ¯ä¸ª `List` æ‰€æŒ‡å‘çš„ `List` è¿˜èƒ½å¤Ÿè¢«ä¿®æ”¹ã€‚

ä¸‹é¢æ¥ä½¿ç”¨ä¸€ä¸‹è¿™ä¸ªå¤æ‚çš„ `List` æšä¸¾ï¼š

```rust
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));
    println!("1 a rc count: {}", Rc::strong_count(&a)); // 1 a rc count: 1
    println!("1 a tail: {:?}", a.tail()); // 1 a tail: Some(RefCell { value: Nil })

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));
    println!("2 a rc count: {}", Rc::strong_count(&a)); // 2 a rc count: 2
    println!("2 b rc count: {}", Rc::strong_count(&b)); // 2 b rc count: 1
    println!("2 a tail: {:?}", b.tail()); // 2 a tail: Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
    
    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    println!("3 a rc count: {}", Rc::strong_count(&a)); // 3 a rc count: 2
    println!("3 b rc count: {}", Rc::strong_count(&b)); // 3 b rc count: 2
}
```

`a`å’Œ`b`çš„å…³ç³»å˜çš„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![](https://rust.hyperter.top/screenshot/ref-loop.png)

ä½†æ˜¯å‡å¦‚æˆ‘ä»¬æ·»åŠ å¦‚ä¸‹ä½œç”¨åŸŸï¼Œ

```rust
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));
    println!("1 a rc count: {}", Rc::strong_count(&a)); // 1 a rc count: 1
    println!("1 a tail: {:?}", a.tail()); // 1 a tail: Some(RefCell { value: Nil })

    {
        let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));
        println!("2 a rc count: {}", Rc::strong_count(&a)); // 2 a rc count: 2
        println!("2 b rc count: {}", Rc::strong_count(&b)); // 2 b rc count: 1
        println!("2 a tail: {:?}", b.tail()); // 2 a tail: Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
        
        if let Some(link) = a.tail() {
            *link.borrow_mut() = Rc::clone(&b);
        }

        println!("3 a rc count: {}", Rc::strong_count(&a)); // 3 a rc count: 2
        println!("3 b rc count: {}", Rc::strong_count(&b)); // 3 b rc count: 2
    }
    // ... å…³äºaçš„ä»£ç 
}
```

`b`åœ¨ç¦»å¼€ä½œç”¨åŸŸä»¥åè¢«é”€æ¯ï¼Œè€Œ`a`å¼•ç”¨`b`ï¼Œå› æ­¤`b`çš„å¼•ç”¨è®¡æ•°ä¸ä¼šå˜æˆ0ï¼Œè€Œæ˜¯å˜æˆ1ã€‚ä½†æ˜¯è¿™ç§æƒ…å†µä¼šå‡ºç°ä¸¤ä¸ªé—®é¢˜ï¼š

- é€ æˆ`b`çš„å†…å­˜æ³„éœ²ï¼Œå› ä¸ºåœ¨`b`ç¦»å¼€ä½œç”¨åŸŸä»¥å¤–çš„ä»£ç ï¼Œ`b`è¢«åˆ†é…åœ¨Rcçš„å †ä¸Šå†…å­˜ä¸ä¼šè¢«ä¸¢å¼ƒ
- æ‰“å°`a.tail()`ä¼šå‡ºç°æ­»å¾ªç¯

åˆ›å»ºå¾ªç¯å¼•ç”¨å¹¶ä¸ç®€å•ï¼Œä½†æ˜¯ä¹Ÿå¹¶ä¸æ˜¯å®Œå…¨é‡ä¸åˆ°ï¼Œå½“ä½ ä½¿ç”¨ `RefCell<Rc<T>>` æˆ–è€…ç±»ä¼¼çš„ç±»å‹åµŒå¥—ç»„åˆï¼ˆå…·å¤‡å†…éƒ¨å¯å˜æ€§å’Œå¼•ç”¨è®¡æ•°ï¼‰æ—¶ï¼Œå°±è¦æ‰“èµ·ä¸‡åˆ†ç²¾ç¥ï¼Œå‰é¢å¯èƒ½æ˜¯æ·±æ¸Šï¼

é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Ÿ å¦‚æœæˆ‘ä»¬ç¡®å®éœ€è¦å®ç°ä¸Šé¢çš„åŠŸèƒ½ï¼Œè¯¥æ€ä¹ˆåŠï¼Ÿç­”æ¡ˆæ˜¯ä½¿ç”¨ `Weak`ã€‚

### å¼±å¼•ç”¨

å¼±å¼•ç”¨`Weak<T>`ï¼š

- å¼±å¼•ç”¨é€šè¿‡`Rc::downgrade`ä¼ é€’Rcå®ä¾‹çš„å¼•ç”¨ï¼Œè°ƒç”¨`Rc::downgrade`ä¼šå¾—åˆ°`Weak<T>`ç±»å‹çš„æ™ºèƒ½æŒ‡é’ˆï¼ŒåŒæ—¶å°†`weak_count`åŠ 1ï¼ˆä¸æ˜¯`strong_count`åŠ 1ï¼‰
- åŒºåˆ«åœ¨äº`weak_count`æ— éœ€è®¡æ•°ä¸º0å°±èƒ½ä½¿Rcå®ä¾‹è¢«æ¸…ç†ã€‚åªè¦`strong_count`ä¸º0å°±å¯ä»¥äº†
- å¯ä»¥é€šè¿‡`Rc::upgrade`æ–¹æ³•è¿”å›`Option<Rc<T>>`å¯¹è±¡

Weak éå¸¸ç±»ä¼¼äº Rcï¼Œä½†æ˜¯ä¸ Rc æŒæœ‰æ‰€æœ‰æƒä¸åŒï¼ŒWeak ä¸æŒæœ‰æ‰€æœ‰æƒï¼Œå®ƒä»…ä»…ä¿å­˜ä¸€ä»½æŒ‡å‘æ•°æ®çš„å¼±å¼•ç”¨ï¼šå¦‚æœä½ æƒ³è¦è®¿é—®æ•°æ®ï¼Œéœ€è¦é€šè¿‡ Weak æŒ‡é’ˆçš„ `upgrade` æ–¹æ³•å®ç°ï¼Œè¯¥æ–¹æ³•è¿”å›ä¸€ä¸ªç±»å‹ä¸º `Option<Rc<T>>` çš„å€¼ã€‚

çœ‹åˆ°è¿™ä¸ªè¿”å›ï¼Œç›¸ä¿¡å¤§å®¶å°±æ‡‚äº†ï¼šä½•ä¸ºå¼±å¼•ç”¨ï¼Ÿå°±æ˜¯ä¸ä¿è¯å¼•ç”¨å…³ç³»ä¾ç„¶å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œå°±è¿”å›ä¸€ä¸ª `None`ï¼

å› ä¸º Weak å¼•ç”¨ä¸è®¡å…¥æ‰€æœ‰æƒï¼Œå› æ­¤å®ƒæ— æ³•é˜»æ­¢æ‰€å¼•ç”¨çš„å†…å­˜å€¼è¢«é‡Šæ”¾æ‰ï¼Œè€Œä¸” Weak æœ¬èº«ä¸å¯¹å€¼çš„å­˜åœ¨æ€§åšä»»ä½•æ‹…ä¿ï¼Œå¼•ç”¨çš„å€¼è¿˜å­˜åœ¨å°±è¿”å› `Some`ï¼Œä¸å­˜åœ¨å°±è¿”å› `None`ã€‚

#### Weakå’ŒRcå¯¹æ¯”

æˆ‘ä»¬æ¥å°† Weak ä¸ Rc è¿›è¡Œä»¥ä¸‹ç®€å•å¯¹æ¯”ï¼š

| Weak | Rc |
|------------------|---------------|
| ä¸è®¡æ•° | å¼•ç”¨è®¡æ•°|
|ä¸æ‹¥æœ‰æ‰€æœ‰æƒ|æ‹¥æœ‰å€¼çš„æ‰€æœ‰æƒ|
|ä¸é˜»æ­¢å€¼è¢«é‡Šæ”¾|æ‰€æœ‰æƒè®¡æ•°å½’é›¶ï¼Œæ‰èƒ½`drop`|
|å¼•ç”¨çš„å€¼å­˜åœ¨è¿”å›`Some`ï¼Œä¸å­˜åœ¨è¿”å›`None`|å¼•ç”¨çš„å€¼å¿…å®šå­˜åœ¨|
|é€šè¿‡`upgrade`å–åˆ°`Option<Rc<T>>`ï¼Œç„¶åå†å–å€¼|é€šè¿‡`Deref`è‡ªåŠ¨è§£å¼•ç”¨ï¼Œå–å€¼æ— éœ€ä»»ä½•æ“ä½œ|

é€šè¿‡è¿™ä¸ªå¯¹æ¯”ï¼Œå¯ä»¥éå¸¸æ¸…æ™°çš„çœ‹å‡º Weak ä¸ºä½•è¿™ä¹ˆå¼±ï¼Œè€Œè¿™ç§å¼±æ°æ°éå¸¸é€‚åˆæˆ‘ä»¬å®ç°ä»¥ä¸‹çš„åœºæ™¯ï¼š

- æŒæœ‰ä¸€ä¸ª Rc å¯¹è±¡çš„ä¸´æ—¶å¼•ç”¨ï¼Œå¹¶ä¸”ä¸åœ¨ä¹å¼•ç”¨çš„å€¼æ˜¯å¦ä¾ç„¶å­˜åœ¨
- é˜»æ­¢ Rc å¯¼è‡´çš„å¾ªç¯å¼•ç”¨ï¼Œå› ä¸º Rc çš„æ‰€æœ‰æƒæœºåˆ¶ï¼Œä¼šå¯¼è‡´å¤šä¸ª Rc éƒ½æ— æ³•è®¡æ•°å½’é›¶

ä½¿ç”¨æ–¹å¼ç®€å•æ€»ç»“ä¸‹ï¼šå¯¹äºçˆ¶å­å¼•ç”¨å…³ç³»ï¼Œå¯ä»¥è®©çˆ¶èŠ‚ç‚¹é€šè¿‡ Rc æ¥å¼•ç”¨å­èŠ‚ç‚¹ï¼Œç„¶åè®©å­èŠ‚ç‚¹é€šè¿‡ Weak æ¥å¼•ç”¨çˆ¶èŠ‚ç‚¹ã€‚

#### Weak æ€»ç»“

å› ä¸º Weak æœ¬èº«å¹¶ä¸æ˜¯å¾ˆå¥½ç†è§£ï¼Œå› æ­¤æˆ‘ä»¬å†æ¥å¸®å¤§å®¶æ¢³ç†æ€»ç»“ä¸‹ï¼Œç„¶åå†é€šè¿‡ä¸€ä¸ªä¾‹å­ï¼Œæ¥å½»åº•æŒæ¡ã€‚

Weak é€šè¿‡ `use std::rc::Weak` æ¥å¼•å…¥ï¼Œå®ƒå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹:

- å¯è®¿é—®ï¼Œä½†æ²¡æœ‰æ‰€æœ‰æƒï¼Œä¸å¢åŠ å¼•ç”¨è®¡æ•°ï¼Œå› æ­¤ä¸ä¼šå½±å“è¢«å¼•ç”¨å€¼çš„é‡Šæ”¾å›æ”¶
- å¯ç”± `Rc<T>` è°ƒç”¨ `downgrade` æ–¹æ³•è½¬æ¢æˆ `Weak<T>`
- `Weak<T>` å¯ä½¿ç”¨ `upgrade` æ–¹æ³•è½¬æ¢æˆ `Option<Rc<T>>`ï¼Œå¦‚æœèµ„æºå·²ç»è¢«é‡Šæ”¾ï¼Œåˆ™ `Option` çš„å€¼æ˜¯ `None`
- å¸¸ç”¨äºè§£å†³å¾ªç¯å¼•ç”¨çš„é—®é¢˜

æˆ‘ä»¬è¿˜æ˜¯ä¸¾`List`çš„ä¾‹å­ï¼š

```rust
use std::{cell::RefCell, rc::{Rc, Weak}};
use crate::List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Weak<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Weak<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}
```
`RefCell`ä¸­çš„`List`å˜ä¸º`Weak`ï¼Œ

```rust
fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Weak::new())));
    println!("1, a strong count: {}, weak count: {}", Rc::strong_count(&a), Rc::weak_count(&a)); // 1, a strong count: 1, weak count: 0
    println!("1, a tail: {:?}", a.tail()); // 1, a tail: Some(RefCell { value: (Weak) })

    let b = Rc::new(Cons(10, RefCell::new(Weak::new())));
    if let Some(link) = b.tail() {
        *link.borrow_mut() = Rc::downgrade(&a);
    }

    println!("2, a strong count: {}, weak count: {}", Rc::strong_count(&a), Rc::weak_count(&a)); // 2, a strong count: 1, weak count: 1
    println!("2, b strong count: {}, weak count: {}", Rc::strong_count(&b), Rc::weak_count(&b)); // 2, b strong count: 1, weak count: 0
    println!("2, b tail: {:?}", b.tail()); // 2, b tail: Some(RefCell { value: (Weak) })

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::downgrade(&b);
    }

    println!("3, a strong count: {}, weak count: {}", Rc::strong_count(&a), Rc::weak_count(&a)); // 3, a strong count: 1, weak count: 1
    println!("3, b strong count: {}, weak count: {}", Rc::strong_count(&b), Rc::weak_count(&b)); // 3, b strong count: 1, weak count: 1
    println!("3, a tail: {:?}", a.tail()); // 3, a tail: Some(RefCell { value: (Weak) })
}
```

ä¸€å¼€å§‹ï¼Œ`a`çš„`weak_count`ä¸º0ï¼Œå› ä¸ºæ²¡æœ‰è¢«å¼•ç”¨ï¼Œå½“`b`çš„å°¾ç«¯æŒ‡å‘`a`ä»¥åï¼Œ`a`çš„`weak_count`å˜ä¸º1ã€‚åŒç†ï¼Œå½“`a`çš„å°¾ç«¯æŒ‡å‘`b`åï¼Œ`b`çš„`weak_count`å˜ä¸º1ã€‚æˆ‘ä»¬è¿™æ—¶å†æ‰“å°`a.tail()`ï¼Œå‘ç°å¹¶ä¸ä¼šå‡ºç°æ­»å¾ªç¯ï¼Œå› ä¸ºå®ƒä¸åœ¨ä¹å¼•ç”¨çš„å€¼æ˜¯å¦ä¾ç„¶å­˜åœ¨ã€‚

## Treeæ•°æ®ç»“æ„

æˆ‘ä»¬å…ˆå®šä¹‰`Node`çš„ç»“æ„ä½“ï¼Œ

```rust
use std::{cell::RefCell, rc::{Rc, Weak}};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    child: RefCell<Vec<Rc<Node>>>,
}
```
ç„¶ååˆ†åˆ«åˆ›å»º`leaf`å­èŠ‚ç‚¹å’Œ`branch`ä½œä¸ºçˆ¶èŠ‚ç‚¹ï¼Œ

```rust
fn main() {
    let leaf = Rc::new(Node{
        value: 3,
        parent: RefCell::new(Weak::new()),
        child: RefCell::new(vec![]),
    });
    println!("1 leaf strong: {}, weak: {}", Rc::strong_count(&leaf), Rc::weak_count(&leaf)); // 1 leaf strong: 1, weak: 0
    println!("leaf parent: {:?}", leaf.parent.borrow().upgrade()); // leaf parent: None

    let branch = Rc::new( Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        child: RefCell::new(vec![Rc::clone(&leaf)]), // branchä½œä¸ºçˆ¶èŠ‚ç‚¹æ‹¥æœ‰leafä½œä¸ºå­èŠ‚ç‚¹
    });
    println!("1 branch strong: {}, weak: {}", Rc::strong_count(&branch), Rc::weak_count(&branch)); // 1 branch strong: 1, weak: 0
    println!("2 leaf strong: {}, weak: {}", Rc::strong_count(&leaf), Rc::weak_count(&leaf)); // 2 leaf strong: 2, weak: 0

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch); // leafèŠ‚ç‚¹çš„parentæŒ‡å‘branchçˆ¶èŠ‚ç‚¹
    println!("2 branch strong: {}, weak: {}", Rc::strong_count(&branch), Rc::weak_count(&branch)); // 2 branch strong: 1, weak: 1
    println!("leaf parent: {:#?}", leaf.parent.borrow().upgrade()); 
    // leaf parent: Some(
    //     Node {
    //         value: 5,
    //         parent: RefCell {
    //             value: (Weak),
    //         },
    //         child: RefCell {
    //             value: [
    //                 Node {
    //                     value: 3,
    //                     parent: RefCell {
    //                         value: (Weak),
    //                     },
    //                     child: RefCell {
    //                         value: [],
    //                     },
    //                 },
    //             ],
    //         },
    //     },
    // )
}
```

## ArcæŒ‡é’ˆ

- Rcå¹¶ä¸æ”¯æŒ`Send trait`å’Œ`Sync trait`ï¼Œä¼šäº§ç”Ÿæ•°æ®ç«äº‰
- Arcå®ç°äº†åŸå­æ“ä½œï¼Œæ˜¯çº¿ç¨‹å®‰å…¨çš„
- Arcæ˜¯æœ‰æ€§èƒ½æŸè€—çš„

Arcæ¥è‡ªäº`std::sync::Arc`ï¼ŒåŒæ ·ä¹Ÿæœ‰`sync`ç‰ˆæœ¬çš„Weakã€‚

```rust
use std::{sync::{Arc, Weak}, thread};

#[derive(Debug)]
struct Owner {
    name: String,
    dogs: Vec<Weak<Dog>>,
}

#[derive(Debug)]
struct Dog {
    owner: Arc<Owner>,
}

fn main() {
    let someone = Arc::new(Owner {
        name: "tom".to_string(),
        dogs: vec![],
    });

    for i in 0..10 {
        let someone = Arc::clone(&someone);
        let join_handle = thread::spawn(move || {
            let yellow_dog = Arc::new(Dog {
                owner: Arc::clone(&someone),
            });
            let black_dog = Arc::new(Dog {
                owner: Arc::clone(&someone),
            });
            println!("yellow dog owner: {}", yellow_dog.owner.name);
            println!("black dog owner: {}", black_dog.owner.name);
            println!("thread {i} end");
        });
        _ = join_handle.join();
    }
}
```