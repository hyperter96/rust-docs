---
title: 变量与常见数据类型
author: 皮特ᴾᵗ
date: 2024/02/04 11:29
categories:
 - Rust语法入门
tags:
 - Rust
 - Rust基础
 - 变量
---

# 变量与常见数据类型

## 变量与不可变性

### Rust中的变量基础知识

1. 在Rust中，使用`let`关键字来声明变量
2. Rust支持类型推导，但你也可以显式指定变量的类型：

    ```rust
    let x: i32 = 5; // 显式指定x的类型为i32
    ```
3. 变量名蛇形命名法 (Snake Case)，而枚举和结构体命名使用帕斯卡命名法 (Pascal Case)，如果变量没有使用到可以前置下划线，消除警告
4. 强制类型转换`Casting a Value to a Different Type`:

    ```rust
    let a = 3.1; let b = a as i32;
    ```
5. 打印变量

    1. `println!("val: {}", x);`
    2. `println!("val: {x}");`

### Rust中的变量是默认不可变的

不可变性是Rust实现其可靠性和安全性目标的关键；

它迫使程序员更深入的思考程序状态的变化，并明确哪些部分的程序状态可能发生变化的；

不可变性有助于防止一类常见错误，如数据竞争和并发问题。

### Shadowing Variables并不是重新赋值

Rust允许你隐藏一个变量，这意味着你可以声明一个与现有变量同名的新变量，从而有效的隐藏前一个变量：

1. 可以改变值

    ```rust
    // shadowing
    let x: i32 = 5;
    {
        let x: i32 = 10;
        println!("inner x: {x}"); // inner x: 10
    } // 内部的x被销毁了
    println!("outer x: {x}"); // outer x: 5
    ```
2. 可以改变类型

    ```rust
    // shadowing
    let x: i32 = 5;
    let x: &str = "hello"; // 在同一作用域下重新声明了x, 最终覆盖了之前的x
    println!("New x: {x}"); // New x: hello
    ```
3. 可以改变可变性

    ```rust
    // shadowing
    let x: i32 = 5;
    let mut x: &str = "this"; // 重新定义可变性
    println!("x: {x}"); // x: this
    x = "that";
    println!("Mut x: {x}"); // Mut x: that
    ```

## 常量`const`和静态变量`static`

### `const`常量

- 常量的值必须是在编译时已知的常量表达式，必须指定类型与值
- 与C语言的宏定义不同，Rust的`const`常量的值被直接嵌入到生成的底层机器代码中，而不是进行简单的字符替换
- 常量名与静态变量命名全部必须是大写，单词之间加入下划线
- 常量的作用域是块级作用域，它只在声明它们的作用域内可见

```rust
// 定义常量
const SECOND_HOUR: usize = 3_600;
const SECOND_DAY: usize = 24 * SECOND_HOUR; // compile-time constant

println!("{}", SECOND_DAY); // 86400
```

### `static`静态变量

1. 与`const`常量不同，`static`变量是在运行时分配内存的
2. 并不是不可变的，可以使用`unsafe`修改
3. 静态变量的生命周期为整个程序的运行时间