---
title: 变量与常见数据类型
author: 皮特ᴾᵗ
date: 2024/02/04 11:29
categories:
 - Rust语法入门
tags:
 - Rust
 - Rust基础
 - 变量
---

# 变量与常见数据类型

## 变量与不可变性

### Rust中的变量基础知识

1. 在Rust中，使用`let`关键字来声明变量
2. Rust支持类型推导，但你也可以显式指定变量的类型：

    ```rust
    let x: i32 = 5; // 显式指定x的类型为i32
    ```
3. 变量名蛇形命名法 (Snake Case)，而枚举和结构体命名使用帕斯卡命名法 (Pascal Case)，如果变量没有使用到可以前置下划线，消除警告
4. 强制类型转换`Casting a Value to a Different Type`:

    ```rust
    let a = 3.1; let b = a as i32;
    ```
5. 打印变量

    1. `println!("val: {}", x);`
    2. `println!("val: {x}");`

### Rust中的变量是默认不可变的

不可变性是Rust实现其可靠性和安全性目标的关键；

它迫使程序员更深入的思考程序状态的变化，并明确哪些部分的程序状态可能发生变化的；

不可变性有助于防止一类常见错误，如数据竞争和并发问题。

### Shadowing Variables并不是重新赋值

Rust允许你隐藏一个变量，这意味着你可以声明一个与现有变量同名的新变量，从而有效的隐藏前一个变量：

1. 可以改变值

    ```rust
    // shadowing
    let x: i32 = 5;
    {
        let x: i32 = 10;
        println!("inner x: {x}"); // inner x: 10
    } // 内部的x被销毁了
    println!("outer x: {x}"); // outer x: 5
    ```
2. 可以改变类型

    ```rust
    // shadowing
    let x: i32 = 5;
    let x: &str = "hello"; // 在同一作用域下重新声明了x, 最终覆盖了之前的x
    println!("New x: {x}"); // New x: hello
    ```
3. 可以改变可变性

    ```rust
    // shadowing
    let x: i32 = 5;
    let mut x: &str = "this"; // 重新定义可变性
    println!("x: {x}"); // x: this
    x = "that";
    println!("Mut x: {x}"); // Mut x: that
    ```

## 常量`const`和静态变量`static`

### `const`常量

- 常量的值必须是在编译时已知的常量表达式，必须指定类型与值
- 与C语言的宏定义不同，Rust的`const`常量的值被直接嵌入到生成的底层机器代码中，而不是进行简单的字符替换
- 常量名与静态变量命名全部必须是大写，单词之间加入下划线
- 常量的作用域是块级作用域，它只在声明它们的作用域内可见

```rust
// 定义常量
const SECOND_HOUR: usize = 3_600;
const SECOND_DAY: usize = 24 * SECOND_HOUR; // compile-time constant

println!("{}", SECOND_DAY); // 86400
```

### `static`静态变量

1. 与`const`常量不同，`static`变量是在运行时分配内存的
2. 并不是不可变的，可以使用`unsafe`修改
3. 静态变量的生命周期为整个程序的运行时间

```rust
static MY_STATIC: i32 = 42;
static mut MY_MUT_STATIC: i32 = 42;

fn main() {
    println!("{MY_STATIC}"); // 42
    unsafe {
        MY_MUT_STATIC = 32;
        println!("{MY_MUT_STATIC}"); // 32
    }
}
```

## Rust基础数据类型

在 Rust 中，每一个值都属于某一个 **数据类型**（*data type*），这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。我们将看到两类数据类型子集：标量（scalar）和复合（compound）。

记住，Rust 是 **静态类型**（*statically typed*）语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时, 使用 `parse` 将 `String` 转换为数字时，必须增加类型注解，像这样：

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

如果不像上面这样添加类型注解 `: u32`，Rust 会显示如下错误，这说明编译器需要我们提供更多信息，来了解我们想要的类型：

```bash
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ consider giving `guess` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
```

你会看到其它数据类型的各种类型注解。

### 标量类型

**标量**（*scalar*）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。你可能在其他语言中见过它们。让我们深入了解它们在 Rust 中是如何工作的。

#### 整型

**整数** 是一个没有小数部分的数字。我们在第二章使用过 `u32` 整数类型。该类型声明表明，它关联的值应该是一个占据 32 比特位的无符号整数（有符号整数类型以 `i` 开头而不是 `u`）。表格 3-1 展示了 Rust 内建的整数类型。我们可以使用其中的任一个来声明一个整数值的类型。

<span class="caption">表格 3-1: Rust 中的整型</span>

| 长度   | 有符号   | 无符号   |
|---------|---------|----------|
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |

每一个变体都可以是有符号或无符号的，并有一个明确的大小。**有符号** 和 **无符号** 代表数字能否为负值，换句话说，这个数字是否有可能是负数（有符号数），或者永远为正而不需要符号（无符号数）。这有点像在纸上书写数字：当需要考虑符号的时候，数字以加号或减号作为前缀；然而，可以安全地假设为正数时，加号前缀通常省略。有符号数以[补码形式（two’s complement representation）](https://en.wikipedia.org/wiki/Two%27s_complement) 存储。

每一个有符号的变体可以储存包含从 -(2<sup>n - 1</sup>) 到 2<sup>n - 1</sup> - 1 在内的数字，这里 *n* 是变体使用的位数。所以 `i8` 可以储存从 -(2<sup>7</sup>) 到 2<sup>7</sup> - 1 在内的数字，也就是从 -128 到 127。无符号的变体可以储存从 0 到 2<sup>n</sup> - 1 的数字，所以 `u8` 可以储存从 0 到 2<sup>8</sup> - 1 的数字，也就是从 0 到 255。

另外，`isize` 和 `usize` 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。

可以使用表格 3-2 中的任何一种形式编写数字字面值。请注意可以是多种数字类型的数字字面值允许使用类型后缀，例如 `57u8` 来指定类型，同时也允许使用 `_` 做为分隔符以方便读数，例如`1_000`，它的值与你指定的 `1000` 相同。

<span class="caption">表格 3-2: Rust 中的整型字面值</span>

| 数字字面值        | 例子          |
|------------------|---------------|
| Decimal (十进制)         | `98_222`      |
| Hex (十六进制)             | `0xff`        |
| Octal (八进制)           | `0o77`        |
| Binary (二进制)          | `0b1111_0000` |
| Byte (单字节字符)(仅限于`u8`) | `b'A'`        |

那么该使用哪种类型的数字呢？如果拿不定主意，Rust 的默认类型通常是个不错的起点，数字类型默认是 `i32`。`isize` 或 `usize` 主要作为某些集合的索引。

> #### 整型溢出
>
> 比方说有一个 `u8` ，它可以存放从零到 `255` 的值。那么当你将其修改为 `256` 时会发生什么呢？这被称为 “整型溢出”（“integer overflow” ），这会导致以下两种行为之一的发生。当在 debug 模式编译时，Rust 检查这类问题并使程序 *panic*，这个术语被 Rust 用来表明程序因错误而退出。第五章 [错误处理之：`Result`、`Option`以及`panic!`宏][unrecoverable-errors-with-panic] 部分会详细介绍 `panic`。
>
> 在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码回绕（*two’s complement wrapping*）的操作。简而言之，比此类型能容纳最大值还大的值会回绕到最小值，值 `256` 变成 `0`，值 `257` 变成 `1`，依此类推。依赖整型回绕被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，[`Wrapping`][wrapping]。
> 为了显式地处理溢出的可能性，你可以使用标准库在原生数值类型上提供的以下方法:
> - 所有模式下都可以使用 `wrapping_*` 方法进行回绕，如 `wrapping_add`
> - 如果 `checked_*` 方法出现溢出，则返回 `None`值
> - 用 `overflowing_*` 方法返回值和一个布尔值，表示是否出现溢出
> - 用 `saturating_*` 方法在值的最小值或最大值处进行饱和处理

#### 浮点型

Rust 也有两个原生的 **浮点数**（*floating-point numbers*）类型，它们是带小数点的数字。Rust 的浮点数类型是 `f32` 和 `f64`，分别占 32 位和 64 位。默认类型是 `f64`，因为在现代 CPU 中，它与 `f32` 速度几乎一样，不过精度更高。所有的浮点型都是有符号的。

这是一个展示浮点数的实例：

```rust [src/main.rs]
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

浮点数采用 IEEE-754 标准表示。`f32` 是单精度浮点数，`f64` 是双精度浮点数。

#### 数值运算

Rust 中的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取余。整数除法会向下舍入到最接近的整数。下面的代码展示了如何在 `let` 语句中使用它们：

```rust [src/main.rs]
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
```

这些语句中的每个表达式使用了一个数学运算符并计算出了一个值，然后绑定给一个变量。[附录 B][appendix_b]<!-- ignore --> 包含 Rust 提供的所有运算符的列表。

#### 布尔型

正如其他大部分编程语言一样，Rust 中的布尔类型有两个可能的值：`true` 和 `false`。Rust 中的布尔类型使用 `bool` 表示。例如：

```rust [src/main.rs]
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```

使用布尔值的主要场景是条件表达式，例如 `if` 表达式。在 [“控制流”(“Control Flow”)][control-flow] 部分将介绍 `if` 表达式在 Rust 中如何工作。

#### 字符类型

Rust的 `char` 类型是语言中最原生的字母类型。下面是一些声明 `char` 值的例子：

```rust [src/main.rs]
fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}
```

:::warning 注意📢：
我们用单引号声明 `char` 字面量，而与之相反的是，使用双引号声明字符串字面量。Rust 的 `char` 类型的大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，带变音符号的字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 `char` 值。Unicode 标量值包含从 `U+0000` 到 `U+D7FF` 和 `U+E000` 到 `U+10FFFF` 在内的值。不过，“字符” 并不是一个 Unicode 中的概念，所以人直觉上的 “字符” 可能与 Rust 中的 `char` 并不符合。第八章的 [“使用字符串存储 UTF-8 编码的文本”][strings] 中将详细讨论这个主题。
:::

[control-flow]: 04-流程控制与函数.md#if流程控制与match模式匹配
[unrecoverable-errors-with-panic]: 05-Error错误处理.md#错误处理之resultoption以及panic宏